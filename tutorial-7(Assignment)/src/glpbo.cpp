/* !
@file    glpbo.cpp
@author  j.jiamin@digipen.edu
@date    08/07/2021

This file contains the definition of structure GLPbo that encapsulates the
functionality required to stream images generated by a 3D graphics pipe
emulator executed on the CPU for display by the GPU.

*//*__________________________________________________________________________*/


#include <glpbo.h>
#include <array>
#include <algorithm>

/* Debugging tool
----------------------------------------------------------------------------- */

#define ASSERT(x) if (!(x)) __debugbreak();
#define GLCall(x) GLClearError();\
	x;\
	ASSERT(GLLogCall(#x , __FILE__ , __LINE__))

/**
 * @brief
 *	The glGetError function returns one of the following error codes, or GL_NO_ERROR if no (more) errors are available. Each error code represents a category of user error.
*/
void GLClearError ()
{
	while( glGetError () != GL_NO_ERROR );
}
/**
 * @brief
 *	A simple function to extract the current OpenGL errors.
 * @param function
 *	It will print out the name of the function .
 * @param file
 *	Which file is located will be printed out.
 * @param line
 *	In which line is the error located at ?
 * @return
 *	Check the console for the errors.
*/
bool GLLogCall ( const char* function , const char* file , int line )
{
	while( GLenum error = glGetError () )
	{
		std::cout
			<< "[OpenGL Error] ( " << error << " )" << std::endl
			<< " Function : " << function << std::endl
			<< " File : " << file << std::endl
			<< " Line : " << line << std::endl;

		return false;
	}
	return true;
}

/* All static members
----------------------------------------------------------------------------- */
GLsizei GLPbo::width{};
GLsizei GLPbo::height{};
GLsizei GLPbo::pixel_cnt{};
GLsizei GLPbo::byte_cnt{};
GLPbo::Color* GLPbo::ptr_to_pbo{ nullptr };
GLuint GLPbo::vaoid{};
GLuint GLPbo::elem_cnt{};
GLuint GLPbo::pboid{};
GLuint GLPbo::texid{};
GLSLShader GLPbo::shdr_pgm{};
GLPbo::Color GLPbo::clear_clr{};
GLPbo::Model GLPbo::model_data{};
std::vector < std::pair < std::string , GLPbo::Model>> GLPbo::all_model_data{};

/* All functions
----------------------------------------------------------------------------- */
void GLPbo::emulate ()
{
	double _cos = cos ( glfwGetTime () ) < 0 ? -cos ( glfwGetTime () ) : cos ( glfwGetTime () );
	double _sin = sin ( glfwGetTime () ) < 0 ? -sin ( glfwGetTime () ) : sin ( glfwGetTime () );
	set_clear_color ( static_cast< int >( _cos * 255.0 ) , static_cast< int >( _cos * 100.0 ) , static_cast< int >( _sin * 255.0 ) );


	ptr_to_pbo = reinterpret_cast< Color* >( glMapNamedBuffer ( pboid , GL_WRITE_ONLY ) );


	clear_color_buffer ();
	for( int i = 0; i < all_model_data.size () ; i++ )
	{
		GLPbo::viewport_transform ( all_model_data[ i ].second );
	}

	for( int i = 0 ; i < all_model_data[ 1 ].second.tri.size (); i += 3 )
	{
		GLPbo::render_triangle ( all_model_data[ 1 ].second.pd[ all_model_data[ 1 ].second.tri[ i ] ] ,
								 all_model_data[ 1 ].second.pd[ all_model_data[ 1 ].second.tri[ i + 1 ] ] ,
								 all_model_data[ 1 ].second.pd[ all_model_data[ 1 ].second.tri[ i + 2 ] ] ,
								 { 255,255,0,255 } );
	}


	/*GLPbo::viewport_transform ( model_data );
	for( int i = 0 ; i < model_data.tri.size (); i += 3 )
	{
		GLPbo::render_triangle ( model_data.pd[ model_data.tri[ i ] ] ,
								 model_data.pd[ model_data.tri[ i + 1 ] ] ,
								 model_data.pd[ model_data.tri[ i + 2 ] ] ,
								 { 255,255,0,255 } );
	}*/


	glUnmapNamedBuffer ( pboid );

	glTextureSubImage2D ( texid , 0 , 0 , 0 , width , height , GL_RGBA , GL_UNSIGNED_BYTE , ptr_to_pbo );
}

void GLPbo::draw_fullwindow_quad ()
{
	glBindTextureUnit ( 3 , texid );
	// use shader
	shdr_pgm.Use ();
	// set texture location
	GLuint tex_loc = glGetUniformLocation ( shdr_pgm.GetHandle () , "uTex2d" );
	glUniform1i ( tex_loc , 3 );
	// GLPbo::vaoid must be initialized with vertex buffers containing 2D position and texture coordinates for a full - window quad.
	glBindVertexArray ( vaoid );
	// draw
	glDrawElements ( GL_TRIANGLE_STRIP , elem_cnt , GL_UNSIGNED_SHORT , nullptr );
}

void GLPbo::init ( GLsizei w , GLsizei h )
{
	std::cout << "Welcome to Tutorial 7 ! \n" << std::endl;

	// Print the specs
	GLHelper::print_specs ();

	// GLPbo::width and GLPbo::height is equivalent to GLHelper::width and GLHelper::height.
	GLPbo::width = w;
	GLPbo::height = h;

	// GLPbo::pixel_cnt will be equivalent to the number of pixels in the PBO while GLPbo::byte_cnt is the number of total bytes in the PBO.
	GLPbo::pixel_cnt = width * height;
	GLPbo::byte_cnt = pixel_cnt * sizeof ( Color );

	// Set the color in data member GLPbo::clear_clr() through GLPbo::set_clear_color ().
	GLPbo::set_clear_color ( 255 , 0 , 255 , 255 );

	// Initialize GLPbo::pboid by creating a PBO with an image store of GLPbo::byte_cnt bytes ( recall the PBO has dimensions GLPbo::width GLPbo::height with each pixel - I use the term pixel rather than texel to conform to the GL spec - having a 32 - bit RGBA value ).
	glCreateBuffers ( 1 , &pboid );
	glNamedBufferStorage ( pboid , byte_cnt , nullptr , GL_DYNAMIC_STORAGE_BIT | GL_MAP_WRITE_BIT );

	// Set GLPbo::ptr_to_pbo to point to the PBO 's address by calling glMapNamedBuffer .
	GLPbo::ptr_to_pbo = reinterpret_cast< GLPbo::Color* >( glMapNamedBuffer ( pboid , GL_WRITE_ONLY ) );

	//	Call GLPbo::clear_color_buffer () to fill PBOmemory store with the value in GLPbo::clear_color .
	GLPbo::clear_color_buffer ();

	// After GLPbo::clear_color_buffer () returns , release PBO's pointer in GLPbo::ptr_to_pbo back to the GPU driver by calling glUnmapNamedBuffer .
	glUnmapNamedBuffer ( pboid );

	// Initialize GLPbo::texid by creating a texture object with storage for a texture image having the same dimensions as the PBO ( which are both equivalent to the dimension of the GL context's colorbuffer). Research GL commands glCreateTextures and glTextureStorage2D .
	GLCall ( glCreateTextures ( GL_TEXTURE_2D , 1 , &texid ) );
	GLCall ( glTextureStorage2D ( texid , 1 , GL_RGBA8 , width , height ) );

	// Initialize the texture image with the PBO's contents using GL command glTextureSubImage2D (specify a 2D texture subimage).
	GLCall ( glTextureSubImage2D ( texid , 0 , 0 , 0 , width , height , GL_RGBA , GL_UNSIGNED_BYTE , ptr_to_pbo ) );

	// Since position coordinates must be defined in NDC , the vertices of the standard box is defined.
	GLPbo::setup_quad_vao ();
	GLPbo::setup_shdrpgm ();

	std::vector < std::string >data ;
	std::ifstream file ( "../scenes/ass-1.scn" );
	if( !file )
	{
		std::cout <<
			"Error : Unable to open scene file : " <<
			"../scenes/ass-1.scn" << std::endl;
		exit ( EXIT_FAILURE );
	}
	else
	{
		std::string line ;
		while( getline ( file , line ) )
		{
			data.push_back ( line );
		}
	}

	for( std::string in_data : data )
	{
		GLPbo::model_data.pm.clear ();
		GLPbo::model_data.nml.clear ();
		GLPbo::model_data.tex.clear ();
		GLPbo::model_data.tri.clear ();

		if( DPML::parse_obj_mesh ( "../meshes/" + in_data + ".obj" , GLPbo::model_data.pm , GLPbo::model_data.nml , GLPbo::model_data.tex , GLPbo::model_data.tri , false , true , true ) )
		{
			std::cout << "../meshes/" << in_data << ".obj" << std::endl;
			GLPbo::all_model_data.push_back ( std::make_pair ( "../meshes/" + in_data + ".obj" , GLPbo::model_data ) );
		}

	}

	file.close ();

	//DPML::parse_obj_mesh ( "../meshes/head.obj" , GLPbo::model_data.pm , GLPbo::model_data.nml , GLPbo::model_data.tex , GLPbo::model_data.tri , false , true , true ) ;


	//for( auto pm : all_model_data[2].second.pm )
	//{
	//	std::cout << pm.x << " " << pm.y << " " << pm.z  << std::endl;
	//}

}

void GLPbo::setup_quad_vao ()
{
	std::array <glm::vec2 , 4 > pos_vtx
	{
		glm::vec2 ( -1.0f, 1.0f ) , glm::vec2 ( -1.0f, -1.0f ),
		glm::vec2 ( 1.0f, 1.0f )  , glm::vec2 ( 1.0f, -1.0f )
	};

	std::array < glm::vec2 , 4 > tex_coordinate
	{
		glm::vec2 ( 0.0f , 1.0f ) , glm::vec2 ( 0.0f , 0.0f ),
		glm::vec2 ( 1.0f , 1.0f ) , glm::vec2 ( 1.0f , 0.0f )
	};

	// Implement vertex buffer object
	GLuint VBO;

	glCreateBuffers ( 1 , &VBO );

	glNamedBufferStorage ( VBO , sizeof ( glm::vec2 ) * pos_vtx.size () + sizeof ( glm::vec2 ) * tex_coordinate.size () , nullptr , GL_DYNAMIC_STORAGE_BIT );

	glNamedBufferSubData ( VBO , 0 , sizeof ( glm::vec2 ) * pos_vtx.size () , pos_vtx.data () );

	glNamedBufferSubData ( VBO , sizeof ( glm::vec2 ) * pos_vtx.size () , sizeof ( glm::vec2 ) * tex_coordinate.size () , tex_coordinate.data () );

	// create and bind vao
	glCreateVertexArrays ( 1 , &vaoid );
	// glEnableVertexAttribArray — enable or disable a generic vertex attribute array
	glEnableVertexArrayAttrib ( vaoid , 0 );
	// glVertexArrayVertexBuffer — bind a buffer to a vertex buffer bind point
	glVertexArrayVertexBuffer ( vaoid , 0 , VBO , 0 , sizeof ( glm::vec2 ) );
	// glVertexArrayAttribFormat — specify the organization of vertex arrays
	glVertexArrayAttribFormat ( vaoid , 0 , 2 , GL_FLOAT , GL_FALSE , 0 );
	// glVertexAttribBinding — associate a vertex attribute and a vertex buffer binding for a vertex array object
	glVertexArrayAttribBinding ( vaoid , 0 , 0 );

	glEnableVertexArrayAttrib ( vaoid , 1 );
	glVertexArrayVertexBuffer ( vaoid , 1 , VBO , sizeof ( glm::vec2 ) * pos_vtx.size () , sizeof ( glm::vec2 ) );
	glVertexArrayAttribFormat ( vaoid , 1 , 2 , GL_FLOAT , GL_FALSE , 0 );
	glVertexArrayAttribBinding ( vaoid , 1 , 1 );

	std::array<GLushort , 4> idx_vtx
	{
		0, 1, 2, 3
	};

	GLuint EBO;
	glCreateBuffers ( 1 , &EBO );
	glNamedBufferStorage ( EBO , sizeof ( GLushort ) * idx_vtx.size () , idx_vtx.data () , GL_DYNAMIC_STORAGE_BIT );
	glVertexArrayElementBuffer ( vaoid , EBO );
	glBindVertexArray ( 0 );

	// delete buffers
	glDeleteBuffers ( 1 , &VBO );
	glDeleteBuffers ( 1 , &EBO );

	elem_cnt = idx_vtx.size ();
}

void GLPbo::setup_shdrpgm ()
{
	const std::string VertexShader
	{
		"#version 450 core\n"
		"layout(location = 0) in vec2 aVertexPosition;\n"
		"layout(location = 1) in vec2 aTexCoord;\n"
		"layout(location = 0) out vec2 vTexCoord;\n"
		"void main()\n"
		"{\n"
		"gl_Position = vec4(aVertexPosition, 0.0, 1.0);\n"
		"vTexCoord = aTexCoord;\n"
		"}"
	};

	const std::string FragmentShader
	{
		"#version 450 core\n"
		"layout(location = 0) in vec2 vTexCoord;\n"
		"layout(location = 0) out vec4 fFragColor;\n"
		"uniform sampler2D uTex2d;\n"
		"void main()\n"
		"{\n"
		"fFragColor = texture(uTex2d, vTexCoord);\n"
		"}"
	};

	std::vector<std::pair<GLenum , std::string>> shdr_list;
	shdr_list.push_back ( std::make_pair ( GL_VERTEX_SHADER , VertexShader ) );
	shdr_list.push_back ( std::make_pair ( GL_FRAGMENT_SHADER , FragmentShader ) );

	for( auto in_shdr_list : shdr_list )
	{
		if( !shdr_pgm.CompileShaderFromString ( in_shdr_list.first , in_shdr_list.second ) )
		{
			std::cout << shdr_pgm.GetLog () << std::endl;
		}
	}

	if( !shdr_pgm.Link () || !shdr_pgm.Validate () )
	{
		std::cout << "shader linked/validate failed." << std::endl;
	}

	shdr_pgm.PrintActiveAttribs ();
	shdr_pgm.PrintActiveUniforms ();
}

void GLPbo::cleanup ()
{
	glDeleteVertexArrays ( 1 , &vaoid );
	glDeleteBuffers ( 1 , &pboid );
	glDeleteTextures ( 1 , &texid );
}

void GLPbo::set_clear_color ( GLPbo::Color glpbo_color )
{
	clear_clr = glpbo_color;
}

void GLPbo::set_clear_color ( GLubyte r , GLubyte g , GLubyte b , GLubyte a )
{
	GLPbo::clear_clr = { r,g,b,a };
}

void GLPbo::clear_color_buffer ()
{
	// Assign clear color to every slots in the first row
	for( int i = 0 ; i < width ; i++ )
	{
		*( GLPbo::ptr_to_pbo + i ) = clear_clr;
	}
	// Duplicated the data of the first row to every subsequent rows
	for( int i = 1 ; i < height ; i++ )
	{
		std::memcpy ( GLPbo::ptr_to_pbo + ( width * i ) , GLPbo::ptr_to_pbo , sizeof ( Color ) * width );
	}
}

void GLPbo::viewport_transform ( Model& model_transfrom )
{
	for( int i = 0 ; i < model_transfrom.pm.size () ; i++ )
	{
		model_transfrom.pd.push_back
		(
			{
				( ( model_transfrom.pm[ i ].x + 1.0f ) / 2.0f ) * GLPbo::height ,
				( ( model_transfrom.pm[ i ].y + 1.0f ) / 2.0f ) * GLPbo::width ,
				0
			}
		);
	}
}

bool GLPbo::render_triangle ( glm::vec3 const& p0 , glm::vec3 const& p1 , glm::vec3 const& p2 , GLPbo::Color clr )
{
	glm::vec3 P1P0 = p1 - p0;
	glm::vec3 P2P0 = p2 - p0;
	glm::vec3 normal =
	{
		P1P0.y * P2P0.z - P1P0.z * P2P0.y,
		P1P0.z * P2P0.x - P1P0.x * P2P0.z,
		P1P0.x * P2P0.y - P1P0.y * P2P0.x
	};
	if( normal.z > 0 )
	{
		render_linebresenham ( p0.x , p0.y , p1.x , p1.y , clr );
		render_linebresenham ( p1.x , p1.y , p2.x , p2.y , clr );
		render_linebresenham ( p2.x , p2.y , p0.x , p0.y , clr );
	}

	glm::vec3 line0 = edge_equation ( p1 , p2 );
	glm::vec3 line1 = edge_equation ( p2 , p0 );
	glm::vec3 line2 = edge_equation ( p0 , p1 );

	float min_x = floor ( std::min ( { p0.x, p1.x ,p2.x } ) );
	float max_x = ceil ( std::max ( { p0.x, p1.x ,p2.x } ) );
	float min_y = floor ( std::min ( { p0.y, p1.y ,p2.y } ) );
	float max_y = ceil ( std::max ( { p0.y, p1.y ,p2.y } ) );

	int Eval0 = PointInEdgeTopLeft ( line0 , { min_x + 0.5f , min_y + 0.5f,0 } );
	int Eval1 = PointInEdgeTopLeft ( line1 , { min_x + 0.5f , min_y + 0.5f,0 } );
	int Eval2 = PointInEdgeTopLeft ( line2 , { min_x + 0.5f , min_y + 0.5f,0 } );

	//for( int y = min_y ; y < max_y ; ++y )
	//{
	//	hEval0 = line0; hEval1 = line1; hEval2 = line2;
	//	for( int x = min_x ; x < max_x ; ++x )
	//	{
	//		PointInEdgeTopLeft()
	//	}
	//}

	return false;
}

bool GLPbo::render_triangle ( glm::vec3 const& p0 , glm::vec3 const& p1 , glm::vec3 const& p2 , glm::vec3 const& c0 , glm::vec3 const& c1 , glm::vec3 const& c2 )
{
	return false;
}

glm::vec3 GLPbo::edge_equation ( glm::vec3 const& p0 , glm::vec3 const& p1 )
{
	return { p0.y - p1.y , p1.x - p0.x , p0.x * p1.y - p1.x * p0.y };
}

bool GLPbo::PointInEdgeTopLeft ( glm::vec3 edge_equation , glm::vec3 arbitrary_point )
{
	int evaluate = ( edge_equation.x * arbitrary_point.x ) + ( edge_equation.y * arbitrary_point.y ) + edge_equation.z;
	if( evaluate > 0 || edge_equation.x > 0 || edge_equation.y < 0 ) return true;
	return false;
}

void GLPbo::line_bresenham_octant0347 ( int x1 , int y1 , int x2 , int y2 , Color clr )
{
	int dx = x2 - x1 , dy = y2 - y1;
	int xstep = ( dx < 0 ) ? -1 : 1;
	int ystep = ( dy < 0 ) ? -1 : 1;
	dx = ( dx < 0 ) ? -dx : dx;
	dy = ( dy < 0 ) ? -dy : dy;
	int d = 2 * dy - dx , dmin = 2 * dy , dmaj = 2 * dy - 2 * dx;
	GLPbo::set_pixel ( x1 , y1 , clr );
	while( --dx > 0 )
	{
		y1 += ( d > 0 ) ? ystep : 0;
		d += ( d > 0 ) ? dmaj : dmin;
		x1 += xstep;
		GLPbo::set_pixel ( x1 , y1 , clr );
	}
}

void GLPbo::line_bresenham_octant1256 ( GLint x1 , GLint y1 , GLint x2 , GLint y2 , GLPbo::Color draw_clr )
{
	int dx = x2 - x1 , dy = y2 - y1;
	int xstep = ( dx < 0 ) ? -1 : 1;
	int ystep = ( dy < 0 ) ? -1 : 1;
	dx = ( dx < 0 ) ? -dx : dx;
	dy = ( dy < 0 ) ? -dy : dy;
	int d = 2 * dx - dy , dmin = 2 * dx , dmaj = 2 * dx - 2 * dy;
	GLPbo::set_pixel ( x1 , y1 , draw_clr );
	while( --dy > 0 )
	{
		x1 += ( d > 0 ) ? xstep : 0;
		d += ( d > 0 ) ? dmaj : dmin;
		y1 += ystep;
		GLPbo::set_pixel ( x1 , y1 , draw_clr );
	}
}

void GLPbo::set_pixel ( int x , int y , Color clr )
{
	if( x < 0 || x >= GLPbo::width || y < 0 || y >= GLPbo::height )
	{
		return;
	}
	else
	{
		int locate = ( GLPbo::width * y ) + x;
		GLPbo::ptr_to_pbo[ locate ] = clr;
	}

}

void GLPbo::render_linebresenham ( GLint px0 , GLint py0 , GLint px1 , GLint py1 , GLPbo::Color draw_clr )
{
	GLint absX = abs ( px1 - px0 );
	GLint absY = abs ( py1 - py0 );
	if( absY <= absX )
	{
		line_bresenham_octant0347 ( px0 , py0 , px1 , py1 , draw_clr );
	}
	else
	{
		line_bresenham_octant1256 ( px0 , py0 , px1 , py1 , draw_clr );
	}

}
