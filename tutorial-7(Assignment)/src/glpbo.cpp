/* !
@file    glpbo.cpp
@author  Jia Min / j.jiamin@digipen.edu
@date    16/07/2021

This file contains the definition of structure GLPbo that encapsulates the
functionality required to stream images generated by a 3D graphics pipe
emulator executed on the CPU for display by the GPU.

*//*__________________________________________________________________________*/


#include <glpbo.h>
#include <array>
#include <algorithm>
#include <chrono>
#include <random>

/* Debugging tool
----------------------------------------------------------------------------- */

#define ASSERT(x) if (!(x)) __debugbreak();
#define GLCall(x) GLClearError();\
	x;\
	ASSERT(GLLogCall(#x , __FILE__ , __LINE__))

/**
 * @brief
 *	The glGetError function returns one of the following error codes, or GL_NO_ERROR if no (more) errors are available. Each error code represents a category of user error.
*/
void GLClearError ()
{
	while( glGetError () != GL_NO_ERROR );
}
/**
 * @brief
 *	A simple function to extract the current OpenGL errors.
 * @param function
 *	It will print out the name of the function .
 * @param file
 *	Which file is located will be printed out.
 * @param line
 *	In which line is the error located at ?
 * @return
 *	Check the console for the errors.
*/
bool GLLogCall ( const char* function , const char* file , int line )
{
	while( GLenum error = glGetError () )
	{
		std::cout
			<< "[OpenGL Error] ( " << error << " )" << std::endl
			<< " Function : " << function << std::endl
			<< " File : " << file << std::endl
			<< " Line : " << line << std::endl;

		return false;
	}
	return true;
}

/* All static members
----------------------------------------------------------------------------- */
GLsizei GLPbo::width{};
GLsizei GLPbo::height{};
GLsizei GLPbo::pixel_cnt{};
GLsizei GLPbo::byte_cnt{};
GLPbo::Color* GLPbo::ptr_to_pbo{ nullptr };
GLuint GLPbo::vaoid{};
GLuint GLPbo::elem_cnt{};
GLuint GLPbo::pboid{};
GLuint GLPbo::texid{};
GLSLShader GLPbo::shdr_pgm{};
GLPbo::Color GLPbo::clear_clr{};
GLPbo::Model GLPbo::model_data{};
std::vector < std::pair < std::string , GLPbo::Model>> GLPbo::all_model_data{};
GLboolean	key_r_last = false;
GLboolean	key_w_last = false;
GLboolean	key_m_last = false;

bool rotate = false;
double rotation_angle = 3.142;
int current_model = 0;

enum class Mode
{
	wireframe_black = 0 ,
	wireframe_color ,
	flat_shaded ,
	smooth_shaded
}mode;

/* All functions
----------------------------------------------------------------------------- */

/**
 * @brief
 * Button M : allows users to iterate through each model in all_model_data .
 * Button W : allows users to iterate through the following render modes:
	Mode 1: render wireframe image using black color
	Mode 2: render wireframe image with each triangle edge rendered using randomly generated color
	Mode 3: render flat shaded triangles using randomly generated triangle color
	Mode 4: render smooth shaded triangles by interpolating per-vertex normal coordinates
 * Button R : allows users to rotate the models' 2D coordinates (with respect to axis).
*/
void GLPbo::emulate ()
{
	double _cos = cos ( glfwGetTime () ) < 0 ? -cos ( glfwGetTime () ) : cos ( glfwGetTime () );

	double _sin = sin ( glfwGetTime () ) < 0 ? -sin ( glfwGetTime () ) : sin ( glfwGetTime () );

	set_clear_color ( static_cast< int >( _cos * 255.0 ) , static_cast< int >( _cos * 100.0 ) , static_cast< int >( _sin * 255.0 ) );

	// binds the pbo buffer
	glBindBuffer ( GL_PIXEL_UNPACK_BUFFER , pboid );

	ptr_to_pbo = reinterpret_cast< Color* >( glMapNamedBuffer ( pboid , GL_WRITE_ONLY ) );

	clear_color_buffer ();

	std::default_random_engine dre;

	dre.seed ( 15 );

	std::uniform_real_distribution<float> urdf ( -1.0 , 1.0 );

	GLPbo::viewport_transform ( all_model_data[ current_model ].second );

	if( GLHelper::keystateM && GLHelper::keystateM != key_m_last )
	{
		++current_model;
		if( current_model >= ( int ) all_model_data.size () )
		{
			current_model = 0;
		}
		rotate = false;
		mode = Mode::wireframe_black;
		rotation_angle = 0.0f;
	}

	if( GLHelper::keystateW && GLHelper::keystateW != key_w_last )
	{
		mode = static_cast< Mode >( static_cast< int >( mode ) + 1 );
		if( static_cast< int >( mode ) > 3 )
		{
			mode = Mode::wireframe_black;
		}
	}

	if( GLHelper::keystateR && GLHelper::keystateR != key_r_last )
	{
		rotate = !rotate;
	}

	key_m_last = GLHelper::keystateM;
	key_r_last = GLHelper::keystateR;
	key_w_last = GLHelper::keystateW;

	if( rotate )
	{
		rotation_angle += GLHelper::update_time () * 2.0;
	}

	for( size_t i = 0 ; i < all_model_data[ current_model ].second.tri.size (); i += 3 )
	{
		GLubyte rand_r = static_cast< GLubyte >( urdf ( dre ) * 255 );
		GLubyte rand_g = static_cast< GLubyte >( urdf ( dre ) * 255 );
		GLubyte rand_b = static_cast< GLubyte >( urdf ( dre ) * 255 );
		switch( mode )
		{
			case Mode::wireframe_black:
				GLPbo::render_triangle_wireframe ( all_model_data[ current_model ].second.pd[ all_model_data[ current_model ].second.tri[ i ] ] ,
												   all_model_data[ current_model ].second.pd[ all_model_data[ current_model ].second.tri[ i + 1 ] ] ,
												   all_model_data[ current_model ].second.pd[ all_model_data[ current_model ].second.tri[ i + 2 ] ] ,
												   { 0, 0, 0 ,255 } );
				break;
			case Mode::wireframe_color:
				GLPbo::render_triangle_wireframe ( all_model_data[ current_model ].second.pd[ all_model_data[ current_model ].second.tri[ i ] ] ,
												   all_model_data[ current_model ].second.pd[ all_model_data[ current_model ].second.tri[ i + 1 ] ] ,
												   all_model_data[ current_model ].second.pd[ all_model_data[ current_model ].second.tri[ i + 2 ] ] ,
												   { rand_r, rand_g ,rand_b,255 } );
				break;
			case Mode::flat_shaded:
				GLPbo::render_triangle ( all_model_data[ current_model ].second.pd[ all_model_data[ current_model ].second.tri[ i ] ] ,
										 all_model_data[ current_model ].second.pd[ all_model_data[ current_model ].second.tri[ i + 1 ] ] ,
										 all_model_data[ current_model ].second.pd[ all_model_data[ current_model ].second.tri[ i + 2 ] ] ,
										 { rand_r, rand_g, rand_b,255 } );
				break;
			case Mode::smooth_shaded:
				GLPbo::render_triangle ( all_model_data[ current_model ].second.pd[ all_model_data[ current_model ].second.tri[ i ] ] ,
										 all_model_data[ current_model ].second.pd[ all_model_data[ current_model ].second.tri[ i + 1 ] ] ,
										 all_model_data[ current_model ].second.pd[ all_model_data[ current_model ].second.tri[ i + 2 ] ] ,
										 all_model_data[ current_model ].second.nml[ all_model_data[ current_model ].second.tri[ i ] ] * 225.0f ,
										 all_model_data[ current_model ].second.nml[ all_model_data[ current_model ].second.tri[ i + 1 ] ] * 225.0f ,
										 all_model_data[ current_model ].second.nml[ all_model_data[ current_model ].second.tri[ i + 2 ] ] * 225.0f );
				break;
		}
	}

	glUnmapNamedBuffer ( pboid );

	// bind the texture
	glBindTexture ( GL_TEXTURE_2D , texid );

	glTextureSubImage2D ( texid , 0 , 0 , 0 , width , height , GL_RGBA , GL_UNSIGNED_BYTE , 0 );

	// unbind buffer
	glBindBuffer ( GL_PIXEL_UNPACK_BUFFER , 0 );

	// unbind texture
	glBindTexture ( GL_TEXTURE_2D , 0 );
}

/**
 * @brief
 * set opengl rectangle quad
*/
void GLPbo::draw_fullwindow_quad ()
{
	glBindTextureUnit ( 3 , texid );

	// use shader
	shdr_pgm.Use ();

	// set texture location
	GLuint tex_loc = glGetUniformLocation ( shdr_pgm.GetHandle () , "uTex2d" );

	glUniform1i ( tex_loc , 3 );

	// GLPbo::vaoid must be initialized with vertex buffers containing 2D position and texture coordinates for a full - window quad
	glBindVertexArray ( vaoid );

	// draw
	glDrawElements ( GL_TRIANGLE_STRIP , elem_cnt , GL_UNSIGNED_SHORT , nullptr );
}

/**
 * @brief
 * initialised the datas
 * @param w
 * @param h
*/
void GLPbo::init ( GLsizei w , GLsizei h )
{
	std::cout << "Welcome to Tutorial 7 ! \n" << std::endl;

	// print the specs
	GLHelper::print_specs ();

	// GLPbo::width and GLPbo::height is equivalent to GLHelper::width and GLHelper::height.
	GLPbo::width = w;

	GLPbo::height = h;

	// GLPbo::pixel_cnt will be equivalent to the number of pixels in the PBO while GLPbo::byte_cnt is the number of total bytes in the PBO.
	GLPbo::pixel_cnt = width * height;

	GLPbo::byte_cnt = pixel_cnt * sizeof ( Color );

	// set the color in data member GLPbo::clear_clr() through GLPbo::set_clear_color ().
	GLPbo::set_clear_color ( 255 , 0 , 255 , 255 );

	// initialize GLPbo::pboid by creating a PBO with an image store of GLPbo::byte_cnt bytes ( recall the PBO has dimensions GLPbo::width GLPbo::height with each pixel - I use the term pixel rather than texel to conform to the GL spec - having a 32 - bit RGBA value ).
	glCreateBuffers ( 1 , &pboid );

	glNamedBufferStorage ( pboid , byte_cnt , nullptr , GL_DYNAMIC_STORAGE_BIT | GL_MAP_WRITE_BIT );

	// binds the pbo buffer
	glBindBuffer ( GL_PIXEL_UNPACK_BUFFER , pboid );

	// set GLPbo::ptr_to_pbo to point to the PBO 's address by calling glMapNamedBuffer .
	GLPbo::ptr_to_pbo = reinterpret_cast< GLPbo::Color* >( glMapNamedBuffer ( pboid , GL_WRITE_ONLY ) );

	// call GLPbo::clear_color_buffer () to fill PBOmemory store with the value in GLPbo::clear_color .
	GLPbo::clear_color_buffer ();

	// after GLPbo::clear_color_buffer () returns , release PBO's pointer in GLPbo::ptr_to_pbo back to the GPU driver by calling glUnmapNamedBuffer .
	glUnmapNamedBuffer ( pboid );

	// initialize GLPbo::texid by creating a texture object with storage for a texture image having the same dimensions as the PBO ( which are both equivalent to the dimension of the GL context's colorbuffer). Research GL commands glCreateTextures and glTextureStorage2D .
	GLCall ( glCreateTextures ( GL_TEXTURE_2D , 1 , &texid ) );

	GLCall ( glTextureStorage2D ( texid , 1 , GL_RGBA8 , width , height ) );

	// initialize the texture image with the PBO's contents using GL command glTextureSubImage2D (specify a 2D texture subimage).
	GLCall ( glTextureSubImage2D ( texid , 0 , 0 , 0 , width , height , GL_RGBA , GL_UNSIGNED_BYTE , 0 ) );

	// unbind pbo buffer
	glBindBuffer ( GL_PIXEL_UNPACK_BUFFER , 0 );

	// unbind texture
	glBindTexture ( GL_TEXTURE_2D , 0 );

	// since position coordinates must be defined in NDC , the vertices of the standard box is defined.
	GLPbo::setup_quad_vao ();

	GLPbo::setup_shdrpgm ();

	// load from file 
	std::vector < std::string >data ;
	std::ifstream file ( "../scenes/ass-1.scn" );
	if( !file )
	{
		std::cout <<
			"Error : Unable to open scene file : " <<
			"../scenes/ass-1.scn" << std::endl;
		exit ( EXIT_FAILURE );
	}
	else
	{
		std::string line ;
		while( getline ( file , line ) )
		{
			data.push_back ( line );
		}
	}

	// for all the data loaded from the obj file  
	for( std::string in_data : data )
	{
		// empty the vector contanier before it is used by DPML::parse_obj_mesh
		GLPbo::model_data.pm.clear ();
		GLPbo::model_data.nml.clear ();
		GLPbo::model_data.tex.clear ();
		GLPbo::model_data.tri.clear ();

		if( DPML::parse_obj_mesh ( "../meshes/" + in_data + ".obj" , GLPbo::model_data.pm , GLPbo::model_data.nml , GLPbo::model_data.tex , GLPbo::model_data.tri , false , true , true ) )
		{
			std::cout << "../meshes/" << in_data << ".obj" << std::endl;
			GLPbo::all_model_data.push_back ( std::make_pair ( "../meshes/" + in_data + ".obj" , GLPbo::model_data ) );
		}

		for( auto& nml : all_model_data.back ().second.nml )
		{
			nml += glm::vec3{ 1 , 1 , 1 };
			nml = nml * 0.5f;
		}

		viewport_transform ( all_model_data.back ().second );
	}
	// close file 
	file.close ();
}

/**
 * @brief
 * setup quad vao using opengl ,
*/
void GLPbo::setup_quad_vao ()
{
	std::array <glm::vec2 , 4 > pos_vtx
	{
		glm::vec2 ( -1.0f, 1.0f ) , glm::vec2 ( -1.0f, -1.0f ),
		glm::vec2 ( 1.0f, 1.0f )  , glm::vec2 ( 1.0f, -1.0f )
	};

	std::array < glm::vec2 , 4 > tex_coordinate
	{
		glm::vec2 ( 0.0f , 1.0f ) , glm::vec2 ( 0.0f , 0.0f ),
		glm::vec2 ( 1.0f , 1.0f ) , glm::vec2 ( 1.0f , 0.0f )
	};

	// Implement vertex buffer object
	GLuint VBO;

	glCreateBuffers ( 1 , &VBO );

	glNamedBufferStorage ( VBO , sizeof ( glm::vec2 ) * pos_vtx.size () + sizeof ( glm::vec2 ) * tex_coordinate.size () , nullptr , GL_DYNAMIC_STORAGE_BIT );

	glNamedBufferSubData ( VBO , 0 , sizeof ( glm::vec2 ) * pos_vtx.size () , pos_vtx.data () );

	glNamedBufferSubData ( VBO , sizeof ( glm::vec2 ) * pos_vtx.size () , sizeof ( glm::vec2 ) * tex_coordinate.size () , tex_coordinate.data () );

	// create and bind vao
	glCreateVertexArrays ( 1 , &vaoid );
	// glEnableVertexAttribArray — enable or disable a generic vertex attribute array
	glEnableVertexArrayAttrib ( vaoid , 0 );
	// glVertexArrayVertexBuffer — bind a buffer to a vertex buffer bind point
	glVertexArrayVertexBuffer ( vaoid , 0 , VBO , 0 , sizeof ( glm::vec2 ) );
	// glVertexArrayAttribFormat — specify the organization of vertex arrays
	glVertexArrayAttribFormat ( vaoid , 0 , 2 , GL_FLOAT , GL_FALSE , 0 );
	// glVertexAttribBinding — associate a vertex attribute and a vertex buffer binding for a vertex array object
	glVertexArrayAttribBinding ( vaoid , 0 , 0 );

	glEnableVertexArrayAttrib ( vaoid , 1 );
	glVertexArrayVertexBuffer ( vaoid , 1 , VBO , sizeof ( glm::vec2 ) * pos_vtx.size () , sizeof ( glm::vec2 ) );
	glVertexArrayAttribFormat ( vaoid , 1 , 2 , GL_FLOAT , GL_FALSE , 0 );
	glVertexArrayAttribBinding ( vaoid , 1 , 1 );

	std::array<GLushort , 4> idx_vtx
	{
		0, 1, 2, 3
	};

	GLuint EBO;
	glCreateBuffers ( 1 , &EBO );
	glNamedBufferStorage ( EBO , sizeof ( GLushort ) * idx_vtx.size () , idx_vtx.data () , GL_DYNAMIC_STORAGE_BIT );
	glVertexArrayElementBuffer ( vaoid , EBO );
	glBindVertexArray ( 0 );

	// delete buffers
	glDeleteBuffers ( 1 , &VBO );
	glDeleteBuffers ( 1 , &EBO );

	elem_cnt = idx_vtx.size ();
}

/**
 * @brief
 * setup shader program using opengl
*/
void GLPbo::setup_shdrpgm ()
{
	const std::string VertexShader
	{
		"#version 450 core\n"
		"layout(location = 0) in vec2 aVertexPosition;\n"
		"layout(location = 1) in vec2 aTexCoord;\n"
		"layout(location = 0) out vec2 vTexCoord;\n"
		"void main()\n"
		"{\n"
		"gl_Position = vec4(aVertexPosition, 0.0, 1.0);\n"
		"vTexCoord = aTexCoord;\n"
		"}"
	};

	const std::string FragmentShader
	{
		"#version 450 core\n"
		"layout(location = 0) in vec2 vTexCoord;\n"
		"layout(location = 0) out vec4 fFragColor;\n"
		"uniform sampler2D uTex2d;\n"
		"void main()\n"
		"{\n"
		"fFragColor = texture(uTex2d, vTexCoord);\n"
		"}"
	};

	std::vector<std::pair<GLenum , std::string>> shdr_list;
	shdr_list.push_back ( std::make_pair ( GL_VERTEX_SHADER , VertexShader ) );
	shdr_list.push_back ( std::make_pair ( GL_FRAGMENT_SHADER , FragmentShader ) );

	for( auto in_shdr_list : shdr_list )
	{
		if( !shdr_pgm.CompileShaderFromString ( in_shdr_list.first , in_shdr_list.second ) )
		{
			std::cout << shdr_pgm.GetLog () << std::endl;
		}
	}

	if( !shdr_pgm.Link () || !shdr_pgm.Validate () )
	{
		std::cout << "shader linked/validate failed." << std::endl;
	}

	shdr_pgm.PrintActiveAttribs ();
	shdr_pgm.PrintActiveUniforms ();
}

/**
 * @brief
 * release unused opengl id
*/
void GLPbo::cleanup ()
{
	glDeleteVertexArrays ( 1 , &vaoid );
	glDeleteBuffers ( 1 , &pboid );
	glDeleteTextures ( 1 , &texid );
}

/**
 * @brief
 * specify clear values for the color buffers
 * @param glpbo_color
 * specify color to be set
*/
void GLPbo::set_clear_color ( GLPbo::Color glpbo_color )
{
	clear_clr = glpbo_color;
}

/**
 * @brief
 * specify clear values for the color buffers
 * @param r , param g , param b , param a
 * Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.
*/
void GLPbo::set_clear_color ( GLubyte r , GLubyte g , GLubyte b , GLubyte a )
{
	GLPbo::clear_clr = { r,g,b,a };
}

/**
 * @brief
 * Program the emulator so that it uses this pointer to write color values directly to the chunk of graphics memory as though it were the emulator's framebuffer using a function such as
set_pixel to write to specific locations in the chunk of memory.
*/
void GLPbo::clear_color_buffer ()
{
	std::fill ( GLPbo::ptr_to_pbo , GLPbo::ptr_to_pbo + pixel_cnt , clear_clr );
}

/**
 * @brief
 * position coordinates must be transformed by viewport transformation matrix to window viewport coordinates pd.
 * @param model_transfrom
 * model data to be transformed
*/
void GLPbo::viewport_transform ( Model& model_transfrom )
{
	// clear model transform container before push back
	model_transfrom.pd.clear ();
	// rotation matrix
	double angle = rotation_angle;
	glm::mat3 m_rotation{ cos ( angle ),  sin ( angle ),	0,
							-sin ( angle ),  cos ( angle ),	0,
								0,		0,		1 };
	for( size_t i = 0 ; i < model_transfrom.pm.size () ; i++ )
	{
		glm::vec3 temp = m_rotation * model_transfrom.pm[ i ];
		model_transfrom.pd.push_back
		(
			{
				( ( temp.x + 1.0f ) / 2.0f ) * GLPbo::height ,
				( ( temp.y + 1.0f ) / 2.0f ) * GLPbo::width ,
				0
			}
		);
	}
}

/**
 * @brief
 * rasterize the triangle primitives to generate wireframe images
 * @param p0
 * 1st vertices of the triangle
 * @param p1
 * 2nd vertices of the triangle
 * @param p2
 * 3rd vertices of the triangle
 * @param clr
 * color to render the triangle edges
 * @return
 * if triangle was successfully rendered which is not backface-culled.
*/
bool GLPbo::render_triangle_wireframe ( glm::vec3 p0 , glm::vec3 p1 , glm::vec3 p2 , GLPbo::Color clr )
{
	glm::vec3 P1P0 = p1 - p0;
	glm::vec3 P2P0 = p2 - p0;
	glm::vec3 normal =
	{
		P1P0.y * P2P0.z - P1P0.z * P2P0.y,
		P1P0.z * P2P0.x - P1P0.x * P2P0.z,
		P1P0.x * P2P0.y - P1P0.y * P2P0.x
	};
	if( normal.z > 0 )
	{
		render_linebresenham ( ( GLint ) p0.x , ( GLint ) p0.y , ( GLint ) p1.x , ( GLint ) p1.y , clr );
		render_linebresenham ( ( GLint ) p1.x , ( GLint ) p1.y , ( GLint ) p2.x , ( GLint ) p2.y , clr );
		render_linebresenham ( ( GLint ) p2.x , ( GLint ) p2.y , ( GLint ) p0.x , ( GLint ) p0.y , clr );
	}
	else
	{
		return false;
	}
	return true ;
}

/**
 * @brief
 * renders a flat shaded triangle
 * @param p0
 * 1st vertices of the triangle
 * @param p1
 * 2nd vertices of the triangle
 * @param p2
 * 3rd vertices of the triangle
 * @param clr
 * color to shade the triangle
 * @return
 * if triangle was successfully rendered which is not backface-culled.
*/
bool GLPbo::render_triangle ( glm::vec3 p0 , glm::vec3 p1 , glm::vec3 p2 , GLPbo::Color clr )
{
	glm::vec3 P1P0 = p1 - p0;
	glm::vec3 P2P0 = p2 - p0;
	glm::vec3 normal =
	{
		P1P0.y * P2P0.z - P1P0.z * P2P0.y,
		P1P0.z * P2P0.x - P1P0.x * P2P0.z,
		P1P0.x * P2P0.y - P1P0.y * P2P0.x
	};
	if( normal.z <= 0 )
	{
		return false;
	}

	glm::vec3 line0 = EdgeEqnTopLeft ( p1 , p2 );
	glm::vec3 line1 = EdgeEqnTopLeft ( p2 , p0 );
	glm::vec3 line2 = EdgeEqnTopLeft ( p0 , p1 );

	float min_x = floor ( std::min ( { p0.x, p1.x ,p2.x } ) );
	float max_x = ceil ( std::max ( { p0.x, p1.x ,p2.x } ) );
	float min_y = floor ( std::min ( { p0.y, p1.y ,p2.y } ) );
	float max_y = ceil ( std::max ( { p0.y, p1.y ,p2.y } ) );

	bool top_left_e0 , top_left_e1 , top_left_e2 ;
	float evaluation0 = EvaluateFragment ( line0 , { min_x + 0.5f , min_y + 0.5f,0 } , top_left_e0 );
	float evaluation1 = EvaluateFragment ( line1 , { min_x + 0.5f , min_y + 0.5f,0 } , top_left_e1 );
	float evaluation2 = EvaluateFragment ( line2 , { min_x + 0.5f , min_y + 0.5f,0 } , top_left_e2 );

	for( int y = ( int ) min_y ; y < ( int ) max_y ; ++y )
	{
		float Hevaluation0 = evaluation0;
		float Hevaluation1 = evaluation1;
		float Hevaluation2 = evaluation2;

		for( int x = ( int ) min_x ; x < ( int ) max_x ; ++x )
		{
			if( PointInTriangleOptimized ( Hevaluation0 , Hevaluation1 , Hevaluation2 , { x + 0.5f , y + 0.5f, 0 } , { 0,0 } , top_left_e0 , top_left_e1 , top_left_e2 ) )
			{
				set_pixel ( x , y , clr );
			}
			Hevaluation0 += line0.x;
			Hevaluation1 += line1.x;
			Hevaluation2 += line2.x;
		}
		evaluation0 += line0.y;
		evaluation1 += line1.y;
		evaluation2 += line2.y;
	}
	return false;
}

/**
 * @brief
 * renders the triangle with smooth shading. I.e. same as flat shading just with barycentric interpolated colors.
 * @param p0
 * 1st vertices of the triangle
 * @param p1
 * 2nd vertices of the triangle
 * @param p2
 * 3rd vertices of the triangle
 * @param c0
 * color at 1st vertex.
 * @param c1
 * color at 2nd vertex.
 * @param c2
 * color at 3rd vertex.
 * @return bool
 * if triangle was successfully rendered which is not backface-culled
*/
bool GLPbo::render_triangle ( glm::vec3 const& p0 , glm::vec3 const& p1 , glm::vec3 const& p2 , glm::vec3 const& c0 , glm::vec3 const& c1 , glm::vec3 const& c2 )
{
	glm::vec3 P1P0 = p1 - p0;
	glm::vec3 P2P0 = p2 - p0;
	glm::vec3 normal =
	{
		P1P0.y * P2P0.z - P1P0.z * P2P0.y,
		P1P0.z * P2P0.x - P1P0.x * P2P0.z,
		P1P0.x * P2P0.y - P1P0.y * P2P0.x
	};
	if( normal.z <= 0 )
	{
		return false;
	}

	glm::vec3 line0 = EdgeEqnTopLeft ( p1 , p2 );
	glm::vec3 line1 = EdgeEqnTopLeft ( p2 , p0 );
	glm::vec3 line2 = EdgeEqnTopLeft ( p0 , p1 );

	float min_x = floor ( std::min ( { p0.x, p1.x ,p2.x } ) );
	float max_x = ceil ( std::max ( { p0.x, p1.x ,p2.x } ) );
	float min_y = floor ( std::min ( { p0.y, p1.y ,p2.y } ) );
	float max_y = ceil ( std::max ( { p0.y, p1.y ,p2.y } ) );

	bool top_left_e0 , top_left_e1 , top_left_e2 ;
	float evaluation0 = EvaluateFragment ( line0 , { min_x + 0.5f , min_y + 0.5f,0 } , top_left_e0 );
	float evaluation1 = EvaluateFragment ( line1 , { min_x + 0.5f , min_y + 0.5f,0 } , top_left_e1 );
	float evaluation2 = EvaluateFragment ( line2 , { min_x + 0.5f , min_y + 0.5f,0 } , top_left_e2 );

	float double_area_triangle = ( p1.x - p0.x ) * ( p2.y - p0.y ) - ( p2.x - p0.x ) * ( p1.y - p0.y );

	float sub_tri_e0 = evaluation0 / double_area_triangle;
	float sub_tri_e1 = evaluation1 / double_area_triangle;
	float sub_tri_e2 = evaluation2 / double_area_triangle;

	float sub_tri_e0_inc_x = line0.x / double_area_triangle;
	float sub_tri_e1_inc_x = line1.x / double_area_triangle;
	float sub_tri_e2_inc_x = line2.x / double_area_triangle;

	float sub_tri_e0_inc_y = line0.y / double_area_triangle;
	float sub_tri_e1_inc_y = line1.y / double_area_triangle;
	float sub_tri_e2_inc_y = line2.y / double_area_triangle;

	for( int y = ( int ) min_y ; y < ( int ) max_y ; ++y )
	{
		float Hevaluation0 = evaluation0;
		float Hevaluation1 = evaluation1;
		float Hevaluation2 = evaluation2;

		float Hsub_tri_e0 = sub_tri_e0;
		float Hsub_tri_e1 = sub_tri_e1;
		float Hsub_tri_e2 = sub_tri_e2;

		for( int x = ( int ) min_x ; x < ( int ) max_x ; ++x )
		{
			if( PointInTriangleOptimized ( Hevaluation0 , Hevaluation1 , Hevaluation2 , { x + 0.5f , y + 0.5f, 0 } , { 0,0 } , top_left_e0 , top_left_e1 , top_left_e2 ) )
			{
				glm::vec3 color = Hsub_tri_e0 * c0 + Hsub_tri_e1 * c1 + Hsub_tri_e2 * c2;
				set_pixel ( x , y , { ( GLubyte ) color.x , ( GLubyte ) color.y , ( GLubyte ) color.z , 255 } );
			}
			Hevaluation0 += line0.x;
			Hevaluation1 += line1.x;
			Hevaluation2 += line2.x;

			Hsub_tri_e0 += sub_tri_e0_inc_x;
			Hsub_tri_e1 += sub_tri_e1_inc_x;
			Hsub_tri_e2 += sub_tri_e2_inc_x;

		}
		evaluation0 += line0.y;
		evaluation1 += line1.y;
		evaluation2 += line2.y;

		sub_tri_e0 += sub_tri_e0_inc_y;
		sub_tri_e1 += sub_tri_e1_inc_y;
		sub_tri_e2 += sub_tri_e2_inc_y;
	}

	return false;
}

/**
 * @brief
 * edge equation calculations for top-left rule
 * @param p0
 * starting point
 * @param p1
 * end point
 * @return
 * if evaluation falls within the edge
*/
glm::vec3 GLPbo::EdgeEqnTopLeft ( glm::vec3 const& p0 , glm::vec3 const& p1 )
{
	return { p0.y - p1.y , p1.x - p0.x , p0.x * p1.y - p1.x * p0.y };
}

/**
 * @brief
 * incorporates work around for top-left rule
 * @param edge_equation
 * the calculated evaluation
 * @param arbitrary_point
 * fragment to be check with
 * @param increment
 * increment on the x or y axis
 * @param top_left
 * if it passed the evaluation of top left rule
 * @return
 * the function will return true if the point is completely inside the edge or on a "top" or "left" edge, otherwise the function returns false
*/
bool GLPbo::PointInEdgeTopLeftOptimized ( float edge_equation , glm::vec3 arbitrary_point , glm::vec2 increment , bool& top_left )
{
	return ( edge_equation > 0 || ( edge_equation == 0 && top_left == true ) ) ? true : false;
}

/**
 * @brief
 * implementing the point-in-triangle test can be rewritten to take advantage of the optimized PointInEdgeTopLeftOptimized test
 * @param e0
 * evaluated value for line 1
 * @param e1
 * evaluated value for line 2
 * @param e2
 * evaluated value for line 3
 * @param arbitrary_point
 * fragment to be check with
 * @param increment
 * increment on the x or y axis
 * @param top_left_e0
 * if it passed the evaluation of top left rule  for line 1
 * @param top_left_e1
 * if it passed the evaluation of top left rule  for line 2
 * @param top_left_e2
 * if it passed the evaluation of top left rule  for line 3
 * @return
 * true if a point is inside the triangle , otherwise false
*/
bool GLPbo::PointInTriangleOptimized ( float const& e0 , float const& e1 , float const& e2 , glm::vec3 const& arbitrary_point , glm::vec2 increment , bool& top_left_e0 , bool& top_left_e1 , bool& top_left_e2 )
{
	if( PointInEdgeTopLeftOptimized ( e0 , arbitrary_point , increment , top_left_e0 ) &&
		PointInEdgeTopLeftOptimized ( e1 , arbitrary_point , increment , top_left_e1 ) &&
		PointInEdgeTopLeftOptimized ( e2 , arbitrary_point , increment , top_left_e2 ) )
		return true;

	return false;
}

/**
 * @brief
 * calculate the evaluation value of a window coordinate to see if its inside or outside an edge
 * @param evaluate_point
 * line to be check with
 * @param arbitrary_point
 * edge to check against
 * @param top_left
 * user provide empty boolean to be filled , return true if pass the top left rules
 * @return
*/
float GLPbo::EvaluateFragment ( glm::vec3 evaluate_point , glm::vec3 const& arbitrary_point , bool& top_left )
{
	top_left = ( evaluate_point.x != 0.0 ) ? ( evaluate_point.x > 0.0 ? true : false ) : ( evaluate_point.y < 0.0 ? true : false );
	return ( evaluate_point.x * arbitrary_point.x ) + ( evaluate_point.y * arbitrary_point.y ) + evaluate_point.z ;
}

/**
 * @brief
 * bresenham line drawing algorithm for if the line falls within octant 0347
 * @param x1
 * starting point x
 * @param y1
 * starting point y
 * @param x2
 * ending point x
 * @param y2
 * ending point y
 * @param clr
 * color of the line to be drawn
*/
void GLPbo::line_bresenham_octant0347 ( int x1 , int y1 , int x2 , int y2 , Color clr )
{
	int dx = x2 - x1 , dy = y2 - y1;
	int xstep = ( dx < 0 ) ? -1 : 1;
	int ystep = ( dy < 0 ) ? -1 : 1;
	dx = ( dx < 0 ) ? -dx : dx;
	dy = ( dy < 0 ) ? -dy : dy;
	int d = 2 * dy - dx , dmin = 2 * dy , dmaj = 2 * dy - 2 * dx;
	GLPbo::set_pixel ( x1 , y1 , clr );
	while( --dx > 0 )
	{
		y1 += ( d > 0 ) ? ystep : 0;
		d += ( d > 0 ) ? dmaj : dmin;
		x1 += xstep;
		GLPbo::set_pixel ( x1 , y1 , clr );
	}
}

/**
 * @brief
 * bresenham line drawing algorithm for if the line falls within octant 1256
 * @param x1
 * starting point x
 * @param y1
 * starting point y
 * @param x2
 * ending point x
 * @param y2
 * ending point y
 * @param clr
 * color of the line to be drawn
*/
void GLPbo::line_bresenham_octant1256 ( GLint x1 , GLint y1 , GLint x2 , GLint y2 , GLPbo::Color draw_clr )
{
	int dx = x2 - x1 , dy = y2 - y1;
	int xstep = ( dx < 0 ) ? -1 : 1;
	int ystep = ( dy < 0 ) ? -1 : 1;
	dx = ( dx < 0 ) ? -dx : dx;
	dy = ( dy < 0 ) ? -dy : dy;
	int d = 2 * dx - dy , dmin = 2 * dx , dmaj = 2 * dx - 2 * dy;
	GLPbo::set_pixel ( x1 , y1 , draw_clr );
	while( --dy > 0 )
	{
		x1 += ( d > 0 ) ? xstep : 0;
		d += ( d > 0 ) ? dmaj : dmin;
		y1 += ystep;
		GLPbo::set_pixel ( x1 , y1 , draw_clr );
	}
}

/**
 * @brief
 * does scizzoring check and sets a color into the specified location in the pbo
 * @param x
 * x-coordinate
 * @param y
 * y-coordinate
 * @param clr
 * color to set the pixel to
*/
void GLPbo::set_pixel ( int x , int y , Color clr )
{
	if( x < 0 || x >= GLPbo::width || y < 0 || y >= GLPbo::height )
	{
		return;
	}
	else
	{
		int locate = ( GLPbo::width * y ) + x;
		GLPbo::ptr_to_pbo[ locate ] = clr;
	}
}

/**
 * @brief
 * renders a line between 2 points using the bresenham line drawing algorithm
 * @param x1
 * starting point x
 * @param y1
 * starting point y
 * @param x2
 * ending point x
 * @param y2
 * ending point y
 * @param draw_clr
 * color of the line to be drawn
*/
void GLPbo::render_linebresenham ( GLint px0 , GLint py0 , GLint px1 , GLint py1 , GLPbo::Color draw_clr )
{
	GLint absX = abs ( px1 - px0 );
	GLint absY = abs ( py1 - py0 );
	if( absY <= absX )
	{
		line_bresenham_octant0347 ( px0 , py0 , px1 , py1 , draw_clr );
	}
	else
	{
		line_bresenham_octant1256 ( px0 , py0 , px1 , py1 , draw_clr );
	}
}
