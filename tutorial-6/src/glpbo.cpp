/* !
@file    glpbo.cpp
@author  j.jiamin@digipen.edu
@date    08/07/2021

This file contains the definition of structure GLPbo that encapsulates the
functionality required to stream images generated by a 3D graphics pipe
emulator executed on the CPU for display by the GPU.

*//*__________________________________________________________________________*/


#include <glpbo.h>
#include <array>
#include <algorithm>

/* Debugging tool
----------------------------------------------------------------------------- */

#define ASSERT(x) if (!(x)) __debugbreak();
#define GLCall(x) GLClearError();\
	x;\
	ASSERT(GLLogCall(#x , __FILE__ , __LINE__))

/**
 * @brief
 *	The glGetError function returns one of the following error codes, or GL_NO_ERROR if no (more) errors are available. Each error code represents a category of user error.
*/
void GLClearError ()
{
	while( glGetError () != GL_NO_ERROR );
}
/**
 * @brief
 *	A simple function to extract the current OpenGL errors.
 * @param function
 *	It will print out the name of the function .
 * @param file
 *	Which file is located will be printed out.
 * @param line
 *	In which line is the error located at ?
 * @return
 *	Check the console for the errors.
*/
bool GLLogCall ( const char* function , const char* file , int line )
{
	while( GLenum error = glGetError () )
	{
		std::cout
			<< "[OpenGL Error] ( " << error << " )" << std::endl
			<< " Function : " << function << std::endl
			<< " File : " << file << std::endl
			<< " Line : " << line << std::endl;

		return false;
	}
	return true;
}

/* All static members
----------------------------------------------------------------------------- */
GLsizei GLPbo::width{};
GLsizei GLPbo::height{};
GLsizei GLPbo::pixel_cnt{};
GLsizei GLPbo::byte_cnt{};
GLPbo::Color* GLPbo::ptr_to_pbo{ nullptr };
GLuint GLPbo::vaoid{};
GLuint GLPbo::elem_cnt{};
GLuint GLPbo::pboid{};
GLuint GLPbo::texid{};
GLSLShader GLPbo::shdr_pgm{};
GLPbo::Color GLPbo::clear_clr{};

/* All functions
----------------------------------------------------------------------------- */
void GLPbo::emulate ()
{
	double _cos = cos ( glfwGetTime () ) < 0 ? -cos ( glfwGetTime () ) : cos ( glfwGetTime () );
	double _sin = sin ( glfwGetTime () ) < 0 ? -sin ( glfwGetTime () ) : sin ( glfwGetTime () );
	set_clear_color ( static_cast< int >( _cos * 255.0 ) , static_cast< int >( _cos * 100.0 ) , static_cast< int >( _sin * 255.0 ) );


	ptr_to_pbo = reinterpret_cast< Color* >( glMapNamedBuffer ( pboid , GL_WRITE_ONLY ) );	

	clear_color_buffer ();


	glUnmapNamedBuffer ( pboid );

	glTextureSubImage2D ( texid , 0 , 0 , 0 , width , height , GL_RGBA , GL_UNSIGNED_BYTE , ptr_to_pbo );
}

void GLPbo::draw_fullwindow_quad ()
{
	glBindTextureUnit ( 3 , texid );
	// use shader
	shdr_pgm.Use ();
	// set texture location
	GLuint tex_loc = glGetUniformLocation ( shdr_pgm.GetHandle () , "uTex2d" );
	glUniform1i ( tex_loc , 3 );
	// GLPbo::vaoid must be initialized with vertex buffers containing 2D position and texture coordinates for a full - window quad.
	glBindVertexArray ( vaoid );
	// draw
	glDrawElements ( GL_TRIANGLE_STRIP , elem_cnt , GL_UNSIGNED_SHORT , nullptr );
}

void GLPbo::init ( GLsizei w , GLsizei h )
{	
	std::cout << "Welcome to Tutorial 6 ! \n" << std::endl;

	// Print the specs
	GLHelper::print_specs ();

	// GLPbo::width and GLPbo::height is equivalent to GLHelper::width and GLHelper::height.
	GLPbo::width = w;
	GLPbo::height = h;

	// GLPbo::pixel_cnt will be equivalent to the number of pixels in the PBO while GLPbo::byte_cnt is the number of total bytes in the PBO.
	GLPbo::pixel_cnt = width * height;
	GLPbo::byte_cnt = pixel_cnt * sizeof ( Color );

	// Set the color in data member GLPbo::clear_clr() through GLPbo::set_clear_color ().
	GLPbo::set_clear_color ( 255, 0 , 255 , 255 );

	// Initialize GLPbo::pboid by creating a PBO with an image store of GLPbo::byte_cnt bytes ( recall the PBO has dimensions GLPbo::width GLPbo::height with each pixel - I use the term pixel rather than texel to conform to the GL spec - having a 32 - bit RGBA value ).
	glCreateBuffers ( 1 , &pboid );
	glNamedBufferStorage ( pboid , byte_cnt , nullptr , GL_DYNAMIC_STORAGE_BIT | GL_MAP_WRITE_BIT );

	// Set GLPbo::ptr_to_pbo to point to the PBO 's address by calling glMapNamedBuffer .
	GLPbo::ptr_to_pbo = reinterpret_cast< GLPbo::Color* >( glMapNamedBuffer ( pboid , GL_WRITE_ONLY ) );

	//	Call GLPbo::clear_color_buffer () to fill PBOmemory store with the value in GLPbo::clear_color .
	GLPbo::clear_color_buffer ();

	// After GLPbo::clear_color_buffer () returns , release PBO's pointer in GLPbo::ptr_to_pbo back to the GPU driver by calling glUnmapNamedBuffer .
	glUnmapNamedBuffer ( pboid );

	// Initialize GLPbo::texid by creating a texture object with storage for a texture image having the same dimensions as the PBO ( which are both equivalent to the dimension of the GL context's colorbuffer). Research GL commands glCreateTextures and glTextureStorage2D .
	GLCall ( glCreateTextures ( GL_TEXTURE_2D , 1 , &texid ) );
	GLCall ( glTextureStorage2D ( texid , 1 , GL_RGBA8 , width , height ) );

	// Initialize the texture image with the PBO's contents using GL command glTextureSubImage2D (specify a 2D texture subimage).
	GLCall ( glTextureSubImage2D ( texid , 0 , 0 , 0 , width , height , GL_RGBA , GL_UNSIGNED_BYTE , ptr_to_pbo ) );

	
	// Since position coordinates must be defined in NDC , the vertices of the standard box is defined.
	GLPbo::setup_quad_vao ();
	GLPbo::setup_shdrpgm ();

}

void GLPbo::setup_quad_vao ()
{
	std::array <glm::vec2 , 4 > pos_vtx
	{
		glm::vec2 ( -1.0f, 1.0f ) , glm::vec2 ( -1.0f, -1.0f ),
		glm::vec2 ( 1.0f, 1.0f )  , glm::vec2 ( 1.0f, -1.0f )
	};

	std::array < glm::vec2 , 4 > tex_coordinate
	{
		glm::vec2 ( 0.0f , 1.0f ) , glm::vec2 ( 0.0f , 0.0f ),
		glm::vec2 ( 1.0f , 1.0f ) , glm::vec2 ( 1.0f , 0.0f )
	};

	// Implement vertex buffer object
	GLuint VBO;
	
	glCreateBuffers ( 1 , &VBO );

	glNamedBufferStorage ( VBO , sizeof ( glm::vec2 ) * pos_vtx.size () + sizeof ( glm::vec2 ) * tex_coordinate.size () , nullptr , GL_DYNAMIC_STORAGE_BIT );

	glNamedBufferSubData ( VBO , 0 , sizeof ( glm::vec2 ) * pos_vtx.size () , pos_vtx.data () );

	glNamedBufferSubData ( VBO , sizeof ( glm::vec2 ) * pos_vtx.size () , sizeof ( glm::vec2 ) * tex_coordinate.size () , tex_coordinate.data () );

	// create and bind vao
	glCreateVertexArrays ( 1 , &vaoid );
	// glEnableVertexAttribArray — enable or disable a generic vertex attribute array
	glEnableVertexArrayAttrib ( vaoid , 0 );
	// glVertexArrayVertexBuffer — bind a buffer to a vertex buffer bind point
	glVertexArrayVertexBuffer ( vaoid , 0 , VBO , 0 , sizeof ( glm::vec2 ) );
	// glVertexArrayAttribFormat — specify the organization of vertex arrays
	glVertexArrayAttribFormat ( vaoid , 0 , 2 , GL_FLOAT , GL_FALSE , 0 );
	// glVertexAttribBinding — associate a vertex attribute and a vertex buffer binding for a vertex array object
	glVertexArrayAttribBinding ( vaoid , 0 , 0 );

	glEnableVertexArrayAttrib ( vaoid , 1 );
	glVertexArrayVertexBuffer ( vaoid , 1 , VBO , sizeof ( glm::vec2 ) * pos_vtx.size () , sizeof ( glm::vec2 ) );
	glVertexArrayAttribFormat ( vaoid , 1 , 2 , GL_FLOAT , GL_FALSE , 0 );
	glVertexArrayAttribBinding ( vaoid , 1 , 1 );

	std::array<GLushort , 4> idx_vtx
	{
		0, 1, 2, 3
	};

	GLuint EBO;
	glCreateBuffers ( 1 , &EBO );
	glNamedBufferStorage ( EBO , sizeof ( GLushort ) * idx_vtx.size () , idx_vtx.data () , GL_DYNAMIC_STORAGE_BIT );
	glVertexArrayElementBuffer ( vaoid , EBO );
	glBindVertexArray ( 0 );

	// delete buffers
	glDeleteBuffers ( 1 , &VBO );
	glDeleteBuffers ( 1 , &EBO );

	elem_cnt = idx_vtx.size ();
}

void GLPbo::setup_shdrpgm ()
{
	const std::string VertexShader
	{
		"#version 450 core\n"
		"layout(location = 0) in vec2 aVertexPosition;\n"
		"layout(location = 1) in vec2 aTexCoord;\n"
		"layout(location = 0) out vec2 vTexCoord;\n"
		"void main()\n"
		"{\n"
		"gl_Position = vec4(aVertexPosition, 0.0, 1.0);\n"
		"vTexCoord = aTexCoord;\n"
		"}"
	};

	const std::string FragmentShader
	{
		"#version 450 core\n"
		"layout(location = 0) in vec2 vTexCoord;\n"
		"layout(location = 0) out vec4 fFragColor;\n"
		"uniform sampler2D uTex2d;\n" 
		"void main()\n"
		"{\n"
		"fFragColor = texture(uTex2d, vTexCoord);\n"
		"}"
	};

	std::vector<std::pair<GLenum , std::string>> shdr_list;
	shdr_list.push_back ( std::make_pair ( GL_VERTEX_SHADER , VertexShader ) );
	shdr_list.push_back ( std::make_pair ( GL_FRAGMENT_SHADER , FragmentShader ) );

	for( auto in_shdr_list : shdr_list )
	{
		if( !shdr_pgm.CompileShaderFromString ( in_shdr_list.first , in_shdr_list.second ) )
		{
			std::cout << shdr_pgm.GetLog () << std::endl;
		}
	}

	if( !shdr_pgm.Link () || !shdr_pgm.Validate () )
	{
		std::cout << "shader linked/validate failed." << std::endl;
	}

	shdr_pgm.PrintActiveAttribs ();
	shdr_pgm.PrintActiveUniforms ();
}

void GLPbo::cleanup ()
{
	glDeleteVertexArrays ( 1 , &vaoid );
	glDeleteBuffers ( 1 , &pboid );
	glDeleteTextures ( 1 , &texid );
}

void GLPbo::set_clear_color ( GLPbo::Color glpbo_color )
{
	clear_clr = glpbo_color;
}

void GLPbo::set_clear_color ( GLubyte r , GLubyte g , GLubyte b , GLubyte a )
{
	GLPbo::clear_clr = { r,g,b,a };
}

void GLPbo::clear_color_buffer ()
{
	// Assign clear color to every slots in the first row
	for( int i = 0 ; i < width ; i++ )
	{
		*( GLPbo::ptr_to_pbo + i ) = clear_clr;
	}

	// Duplicated the data of the first row to every subsequent rows
	for( int i = 1 ; i < height ; i++ )
	{
		std::memcpy ( GLPbo::ptr_to_pbo + ( width * i ) , GLPbo::ptr_to_pbo , sizeof(Color)* width );
	}
}